/** 
 * 
 */
package io.sarl.airsim.simulation.behaviors

import io.sarl.airsim.simulation.capacities.SimulationControlCapacity
import io.sarl.airsim.simulation.framework.events.PerceptionsPropagated
import io.sarl.airsim.simulation.framework.events.RetrievePerceptions
import io.sarl.airsim.simulation.framework.events.StartSimulation
import io.sarl.airsim.simulation.framework.events.SimulationInitialized
import io.sarl.airsim.simulation.framework.utils.ActiveWaitLock
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Logging

import static io.sarl.airsim.simulation.framework.scheduling.FixedStepBlockingSimulationStrategy.fixedStepBlockingSimulationStrategy
import static io.sarl.airsim.simulation.framework.scheduling.RealTimeSimulationStrategy.realTimeSimulationStrategy

import io.sarl.core.Schedules

/** 
 * Simulation controller behavior
 * @author Alexandre Lombard
 * 
 */
behavior SimulationController {
	uses Logging, DefaultContextInteractions, Schedules
	
	uses SimulationControlCapacity

	/** Simulation step */
	val simulationStepMs = 200.0f

	/**	Internal lock */
	val influencesPropagated = new ActiveWaitLock()
	
	on StartSimulation {
		info("Start Simulation event received...")
		
		simPause(true)
		
		val simulationStrategy = fixedStepBlockingSimulationStrategy [
			retrievePerceptionsBy = [ retrievePerceptions ]
			canContinueIf = [!influencesPropagated.isLocked]
			continueSimulationBy = [
				info("Continuing simulation (begin)...")
				simContinueForTime(simulationStepMs / 1000.0f)
				Thread.sleep(simulationStepMs.longValue)
				influencesPropagated.lock
				info("Continuing simulation (end)...")
			]
		]

//		simPause(false)
//
//		val simulationStrategy = realTimeSimulationStrategy [
//			retrievePerceptionsBy = [ retrievePerceptions ]
//		]

		atFixedDelay(simulationStepMs.longValue) [simulationStrategy.loop]
		
		emit(new SimulationInitialized)
	}
	
	on PerceptionsPropagated {
		info("Perceptions propagated...")
		
		influencesPropagated.unlock
	}
	
	private def retrievePerceptions {
		emit(new RetrievePerceptions)
	}
	
}
